def nonrecursive(iterable):  # Функция без рекурсии, принимаем только исходный список
    nested = True  # Наш стоп-сигнал, если нашли список, словарь, множество или кортеж
    exception2 = (list, tuple, set)  # Список элементов для стоп-сигнала (кроме словаря, к нему отдельный подход)
    while nested:  # Работаем бесконечно пока стоп-сигнал True
        new2 = []  # Новый список, где будем временно хранить текущую распаковку
        nested = False  # Стоп-сигнал Ложь, останется таковым, только тогда, когда пробежим весь список и распакуем.
        # Только тогда выйдем из while
        for i in iterable:  # Пробегаем весь список
            if isinstance(i,
                          exception2):  # Если нашли тип данных который записан в исключении, например ещё один список
                new2.extend(i)  # С помощью .extend() добавляем в конец new2 все элементы внутри этого исключения
                nested = True  # Стоп-Сигнал правда, вдруг там еще вложения, нужно работать дальше
            elif isinstance(i, dict):  # Иначе Если у нас словарь
                new2.extend(i.items())  # С помощью .extend() добавляем в конец new2 все элементы внутри этого
                # исключения, элементы из словаря достаём с помощью .items()
                nested = True  # Стоп-Сигнал правда, вдруг там еще вложения, нужно работать дальше
            else:  # Иначе
                new2.append(i)  # Просто добавляем с помощью .append() текущий элемент в конец списка new2
        iterable = new2  # Берём всё что распаковали на текущий момент и закидываем как изначальный список,
        # чтобы пробежать его заново
    return iterable  # Возвращаем распакованный список
test = [None, [1, ({2, 3}, {'foo': 'bar'})]]  # Исходный список с вложениями
print(test)
print(nonrecursive(test))  # Вызываем функцию распаковки списка без рекурсии и её итог выводим на экран
